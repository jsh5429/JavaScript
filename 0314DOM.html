<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./css.0315style.css">
</head>
<body>
    <!-- 아래에 태그에 접근해서 속성값 바꾸기 -->
    <!-- innerHTML 사용 -->
    <h1 id ="title">DOM</h1>
    <p class="class-name">내용을 작성하였습니다.</p>
    <ol id = "list">
        <li>1</li>
        <li>2</li>
        <li>3</li>
    </ol>
    <a href="#">다음으로 연결</a>
    <form id="form">
        <label for="">이름</label>
        <input type="text" id="name">
    </form>

    <ul id="list2">
        <li>요소</li>
        <li>요소</li>
        <li>요소</li>
        텍스트
    </ul>
    <script>
        /* DOM : 도큐먼트 오브젝트 모델 : 문서객체 모델 */
        // html의 요소를 객체로 선택하거나 생성

        // html 요소 선택
        let title = document.querySelector("#title");
        console.log(title);
        let list = document.querySelector("#list");
        // 현재 list는 Element속성으로 문서 객체에 들어간걸 알수있다.
        console.log(list);
        // console.dir은 문서 객체를 객체 형태로 출력해서 보여줌
        console.dir(list);

        //document.querySelector()를 사용하면 하나의 요소를 가져오고
        // document.querySelectorAll()를 사용하면 여러 개의 요소를
        // 배열에 넣어서 가져온다.
        // document.getElement~, document.getElements~의
        // 이름에 따라서 한 개의 요소 또는 배열로 들고 온다.

        let element = document.createElement("h1");
        // 요소의 속성 추가/수정
        // innerHTML 요소 안의 내용 변경
        // .을 통해 속성에 접근
        // .style 객체의 속성에 접근하여 변경
        element.innerHTML = "원하는 값 작성";
        element.id = "title2";
        element.style.color = "red";

        // querySelector를 이용한 요소 선택과
        // innerHTML을 이용한 내부 내용 작성
        let classElement = document.querySelector(".class-name");
        classElement.innerHTML = "클래스를 통해 수정된 내용입니다.";
        let title2 = document.querySelector("#title");
        title2.innerHTML = "아이디를 들고 와서 수정된 내용입니다.";
        title.innerHTML = "DOM";

        // querySelectorAll() : 배열로 요소들을 들고 옴
        let listLi = document.querySelectorAll("#list>li");
        console.log(listLi);

        // 인덱스 값으로 접근해서 바꾸기
        listLi[0].innerHTML = "요소를 수정한 내용입니다.";
        listLi[1].innerHTML = "요소를 수정한 내용입니다.";
        listLi[2].innerHTML = "요소를 수정한 내용입니다.";

        // for문을 통해서 내용을 바꾸기
        // for - 배열 in / lenght
        let array = ["HTML", "CSS", "JavaScript"];
        for(let i=0; i<listLi.length; i++){
        listLi[i].innerHTML = array[i];
        }

        // querySelector를 이용하여 <a>태그를 가져온 후
        // href를 다음 홈페이지로 변경
        /*let hyper = document.querySelector('a').setAttribute("href",
        "https://www.daum.net/");
        */


        // querySelector를 이용하여 id가 form인 form태그에서
        // input태그를 가져온 후 속성을 disabled=true로 변경
        /*
        let form1 = document.querySelector("#form>input").setAttribute("disabled", "true");
        */

        let a = document.querySelector("a");
        a.href = "https://www.daum.net/";

        let input = document.querySelector("#form>#name");
        // querySelector()이용하여 요소를 찾미 못하면 null이 들어간다.
        console.log(input);
        // null에서 속성을 접근할 수 없기때문에 오류가 출력된다.
        input.disabled = "true";


        // DOM 요소의 스타일 속성
        classElement.style.backgroundColor = "yellow";
        title2.style.textDecoration = "line-through";

        for(let i=0; i<listLi.length; i++){
        listLi[i].style.color="blue";
        }

        // Node : DOM객체의 내용을 text/element/attr로 구분
        // 객체를 글자와 태그와 속성으로 구분하는 단위
        // .childNodes에서 태그와 글자로 구분되어 들어가 있음.
        // title2.parentNode , title2.parentElement
        // 둘다 결과가 같다. 편한걸 쓴다.
        
        // 노드로의 접근
        // 부모 : parentNode, parentElement
        // 자식 (각각 배열로 들어간다.): childNodes, children
        // 첫번째, 마지막 자식 : firstChild, firstElementChild
        // lastChild, lastElementChild
        // 형제 : nextSibling, netxElementSibling / previousSibling
        // 각 부모나 형제로 접근한 뒤에 그 속성에 다시 부모나 형제자식에게
        // 접근 가능하다.
        
        // list의 2번재 li인 CSS 값을 출력
        // 1) list 요소에 .을 통해 찾기
        console.log("요소찾기", list.firstElementChild.nextElementSibling);

        // 2) list 요소의 첫번쨰 자식을 변수로 저장한 후 찾기
        let child = list.firstElementChild;
        console.log("요소찾기2", child.nextElementSibling);

        // 노드로의 접근 실습1
        console.log("노드로의 접근1", title.childNodes);
        // title.childNodes[0].nodeValue : nodeValue를 가져올수있다.
        let list3 = document.querySelector("#list2>li");
        console.log("노드로의 접근 1-2", list3.parentNode.nextElementSibling);
        let ul1 = document.querySelector("#list2");
        console.log("노드로의 접근1-3", ul1.firstChild.nextSibling);
        

        // 노드 접근 실습1
        // h1태그의 childNode
        let h1 = document.querySelector("h1");
        console.log(h1.childNodes[0].nodeValue);

        // li태그의 parentNode와 nextElementSibling
        let li = document.querySelector("li");
        console.log(li.parentNode.nextElementSibling);

        // ul 태그의 firstchild와 nextSibling
        let ul = document.querySelector("ul");
        // 요소가 아니라 노드로 접근 때문에 firstChild는
        // li가 아니라 text이다. 따라서 firstChild의 nextSibling은
        // li가 된다.
        console.log(ul.firstChild.nextSibling);

        // 노드 관리 - 생성과 추기
        let element2 = document.createElement("h2");
        // 속성과 텍스트 생성
        let attr = document.createAttribute("style");
        let text = document.createTextNode("h2태그생성");

        // 속성 추가
        element2.setAttributeNode(attr);
        // 글자 추가 : textNode이므로 appendChild를 통해 추기

        element2.appendChild(text);
        // body에 추가
        let body = document.querySelector("body");
        body.appendChild(element2);

        // 속성고 태그 안의 글자의 경우
        // DOM 속성에 접근해서 값을 바꿀 수 있다.
        element2.style.color="blue";
        element2.innerHTML = "값 작성";
        element2.textContent = "값 수정";

        // 동일한 객체를 다른 곳에 추가
        // ul.appendChild(element2)를 하면 element2가
        // ul 리스트 안에 들어가게된다.
        ul.appendChild(element2);
        // body에 append되어있던 element2가 ul로 append되어
        // 이동
        // 동일한 객체는 html 문서에서 한번만 사용가능
        // 즉 element2는 html에 문서에 한번 더 추가해도 나오지않는다.

        // 동일한 객체를 여러번 html 문서에 사용하고 싶을 때는
        // 노드를 복제한다.
        /* 객체(배열)을 복제하는 경우와 비슷하다. 
        객체는 동일한 새로운 객체를 만들 때 메소드를 사용한다.*/
        let element3 = element2.cloneNode(true);
        // element2의 복제 element3를 body에 다시 넣는다.
        body.appendChild(element3);
        element3.innerHTML = "요소3";
        
        // 노드의 삭제
        // ul태그의 첫번쨰 자식 li 삭제 > return DOM
        ul.removeChild(ul.firstElementChild);
        // ul태그의 첫번째 자식으로 들어가서 자기 자신 삭제
        // return 값 없음. 따라서 지운 뒤에 복구를 생각하고있다면
        // 위의 방법이 효율적
        ul.firstElementChild.remove();
        
        // 노드의 관리 실습 1
        // 생성, 추가
        let p = document.createElement('p');
        body.appendChild(p);
        
        let pText = document.createTextNode("textnode를 이용한 텍스트입니다.");
        p.appendChild(pText);
        // textnode로 만든 pText도 단순 복제가 되지 않기 때문에
        // body에 pText를 append하면 p태그의 pText가 사라진다.
        // body.appendChild(pText);
        // 요소의 속성값 수정
        p.style.color = "blue";
        /* 내 오답
        let pColor = document.createAttribute(p.style);
        p.setAttributeNode(pColor);
        아니 setAttributeNode 쓰라매~!
        */
        pText.nodeValue = "<span>textNode</span>의 nodeValue접근하여 수정";
        // innerHTML과 textNode의 차이
        // textContent로 넣어도 죄다 글자로 들어간다.
        // textNode는 그 안에 들어가는 내용은 모두 글자로 들어간다.
        // textContent도 동일하게 모두 글자로 들어간다.
        // innerHTML은 그 안에 태그를 작성하면 태그는 반영해서 사용한다.

        // 노드의 관리 실습 2
        // 제거
        // p태그의 style 속성 제거. 지금 아래 코드때문에
        // 임의로 주석 상태로 바꿔서 지운 상태임.
        // p.removeAttribute("style");
        ul.removeChild(ul.firstElementChild);
        ul.remove();

        // 노드의 관리 실습 3
        // 복제
        // h1 태그를 복제하여 body에 바로 추가
        // 변수에 할당하지 않고 추가하면 자바스크립트에서 제어할 수 없다.
        // 다시 document.querySelector를 통해 가져와서 제어할 수 있다.
        body.appendChild(h1.cloneNode(true));
        // p 태그를 복제하여 body에 추가
        let cloneP = p.cloneNode(true);
        body.appendChild(cloneP);
        // 변수에 할당하면 자바스크립트로 태그에 관여할 수 있다.
        cloneP.removeAttribute("style");

    </script>
</body>
</html>